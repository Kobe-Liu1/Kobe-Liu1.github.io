<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法篇四(二分法和动态规划)</title>
      <link href="/p/11318e4f.html"/>
      <url>/p/11318e4f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分法和动态规划"><a href="#二分法和动态规划" class="headerlink" title="二分法和动态规划"></a>二分法和动态规划</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>&emsp;给定一个无序的整数数组，找到其中最长上升子序列的长度。<br>&emsp;&emsp;输入: [10,9,2,5,3,7,101,18]<br>&emsp;&emsp;输出: 4<br>&emsp;&emsp;解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。  </p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>&emsp;1.概念：动态规划就是把一个大问题拆成一个个小问题(分治思想)，但是动态规划的核心并不在此，而是那些小问题会不会被复用。<br>&emsp;&emsp;1.举个简单的例子：在纸上写上1+1+1，问它的和是多少，都知道是1+1+1=3，之后在1+1+1之前再写上一个1+，问它的和，这时候有两种计算方法，第一种是1+1+1+1=4,而另一种方法是1+3=4，因为之前我们已经计算了1+1+1了，就无需再次计算了，这就是动态规划。<br>&emsp;&emsp;2.走楼梯的例子：有n级台阶，人只能一次走1级或者2级，问这个人有多少种走法？<br>&emsp;&emsp;&emsp;f(1)=1,第一次只能跳一级；f(2)=2,第二次可以跳一级或者两级；第三次f(3)=f(2)+f(1),即如果第一次跳一格，那么有f(2)种跳法，第一次跳两格，那么就f(1)次跳法，由此类推f(n)=f(n-1)+f(n-2);</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>&emsp;1.概念：在用二分法进行查找时，查找对象的数组必须是有序的，即各数组元素的次序是按其值的大小顺序存储的。其基本思想是先确定待查数据的范围（可用 [left,right] 区间表示），然后逐步缩小范围直到找到或找不到该记录为止。具体做法是：先取数组中间位置（mid=(left+right)/2）的数据元素与给定值比较。若相等，则查找成功；否则，若给定值比该数据元素的值小（或大），则给定值必在数组的前半部分[left,mid-1]（或后半部分[mid+1,right]），然后在新的查找范围内进行同样的查找。如此反复进行，直到找到数组元素值与给定值相等的元素或确定数组中没有待查找的数据为止。因此，二分查找每查找一次，或成功，或使查找数组中元素的个数减少一半，当查找数组中不再有数据元素时，查找失败。<br>&emsp;2.例子：编写一个计算x的平方根的程序，x保证为正数，求：5的平方根：<br>&emsp;&emsp;思路：设f(x)=x2,f(x)随x的增大而增大，所以我们采取二分法，首先，我们令mid = (left+right)/2,用mid的平方与5比较:<br>&emsp;&emsp;1) f(mid)&gt;5,令right=mid；<br>&emsp;&emsp;2) f(mid)&lt;5,令left=mid;</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>&emsp;1.动态规划解题<br>&emsp;&emsp;解题思路：<br>&emsp;&emsp;状态定义：dp[i]代表前i个数字的最长序列长度<br>&emsp;&emsp;转移思想：设j∈[0,i)，考虑每轮计算新 dp[i]时，遍历[0,i)列表区间，做以下判断:<br>&emsp;&emsp;&emsp;1) num[i]&gt;num[j]时，num[i]可以接在num[j]之后，此情况下最长上升子串dp[i]=dp[j]+1<br>&emsp;&emsp;&emsp;2) num[i]&lt;num[j]时，num[i]不可以接在num[j]之后，跳过<br>&emsp;&emsp;执行方程：dp[i]=max(dp[i],dp[j]+1)<br>&emsp;&emsp;代码如下：<br>    <code>private int lengthOfLIS(int[] nums) {        if(nums.length == 0){            return 0;        }        int[] dp = new int[nums.length];        int res = 0;        Arrays.fill(dp,1);        for(int i=0;i&lt;nums.length;i++){            for(int j=0;j&lt;i;j++){                if(nums[j]&lt;nums[i]){                    dp[i] = Math.max(dp[i],dp[j]+1);                }            }            res = Math.max(res,dp[i]);        }        return res;    }</code><br>&emsp;2.动态规划+二分法解题<br>&emsp;&emsp;思路：主要问题是如何降低时间复杂度：<br>&emsp;&emsp;&emsp;1.动态规划中，通过线性遍历来计算dp的复杂度O(n)无法降低<br>&emsp;&emsp;&emsp;2.需要通过线性遍历[0,k)区间元素来得到，我们可以通过重新定义状态，使整个列表变成一个顺序列表，这样在计算每个 dp[k]dp[k]dp[k] 时，就可以通过二分法遍历[0,k)区间元素，将此部分复杂度由O(N)降至 O(logN)<br>&emsp;&emsp;代码：<br>    <code>private int lengthOfLIS1(int[] nums) {        int[] tails = new int[nums.length];        int res = 0;        for(int num : nums) {            int i = 0, j = res;            while(i &lt; j) {                int m = (i + j) / 2;                if(tails[m] &lt; num) i = m + 1;                else j = m;            }            tails[i] = num;            if(res == j) res++;        }        return res;    }</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第七弹)</title>
      <link href="/p/3830ca5f.html"/>
      <url>/p/3830ca5f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="遇到的有意思的jar包"><a href="#遇到的有意思的jar包" class="headerlink" title="遇到的有意思的jar包"></a>遇到的有意思的jar包</h1><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h3><p>lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。</p><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="2.好处："></a>2.好处：</h3><p>减少冗余代码，使代码更加简洁精炼  </p><h3 id="3-如何用："><a href="#3-如何用：" class="headerlink" title="3.如何用："></a>3.如何用：</h3><p>&emsp;1.lombok是一个IDE插件，首先在maven的pom文件中引进jar包：</p><pre><code>    &lt;dependency&gt;         &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;         &lt;artifactId&gt;lombok&lt;/artifactId&gt;         &lt;version&gt;1.16.10&lt;/version&gt;     &lt;/dependency&gt;</code></pre><p>&emsp;2.以我用的idea举例，在setting-&gt;plugins 中下载lombok插件，重启IDE<br>&emsp;之后你就会发现在项目中只要在pojo类中添加@Data关键字，就可以不用写getter，setter方法了  </p><h3 id="4-lombok相关注解："><a href="#4-lombok相关注解：" class="headerlink" title="4.lombok相关注解："></a>4.lombok相关注解：</h3><p>&emsp;1.@NonNull：可以帮我们避免空指针<br>&emsp;&emsp;不使用lombok：  </p><pre><code>public class NonNullExample extends Something {     private String name;     public NonNullExample(@NonNull Person person) {         super(&quot;Hello&quot;);         if (person == null) {             throw new NullPointerException(&quot;person&quot;);         }         this.name = person.getName();     } }  </code></pre><p>&emsp;&emsp;使用lombok：  </p><pre><code>import lombok.NonNull; public class NonNullExample extends Something {     private String name;     public NonNullExample(@NonNull Person person) {         super(&quot;Hello&quot;);         this.name = person.getName();     } }  </code></pre><p>&emsp;2.@Cleanup: 自动帮我们调用close()方法<br>&emsp;&emsp;不使用lombok：  </p><pre><code>import java.io.*; public class CleanupExample {     public static void main(String[] args) throws IOException {         InputStream in = new FileInputStream(args[0]);         try {             OutputStream out = new FileOutputStream(args[1]);             try {                 byte[] b = new byte[10000];                 while (true) {                     int r = in.read(b);                     if (r == -1) break;                     out.write(b, 0, r);                 }             }             finally {                 if (out != null) {                     out.close();                 }             }         }         finally {             if (in != null) {                 in.close();             }         }     } } </code></pre><p>&emsp;&emsp;使用lombok：  </p><pre><code>import lombok.Cleanup; import java.io.*; public class CleanupExample {     public static void main(String[] args) throws IOException {         @Cleanup InputStream in = new FileInputStream(args[0]);         @Cleanup OutputStream out = new FileOutputStream(args[1]);         byte[] b = new byte[10000];         while (true) {             int r = in.read(b);             if (r == -1) {            break;             out.write(b, 0, r);         }     } }  </code></pre><p>&emsp;3.@Getter/@Setter:自动生成Getter/Setter方法<br>&emsp;&emsp;不使用lombok：</p><pre><code>public class GetterSetterExample {     private int age = 10;     private String name;     public int getAge() {         return age;     }     public void setAge(int age) {         this.age = age;     }     protected void setName(String name) {         this.name = name;     } }  </code></pre><p>&emsp;&emsp;使用lombok：  </p><pre><code>import lombok.AccessLevel; import lombok.Getter; import lombok.Setter; public class GetterSetterExample {     @Getter @Setter private int age = 10;     @Setter(AccessLevel.PROTECTED) private String name; }  </code></pre><p>&emsp;4.@NoArgsConstructor: 自动生成无参数构造函数。<br>&emsp;5.@AllArgsConstructor: 自动生成全参数构造函数。<br>&emsp;6.@Data: 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor!  </p><h2 id="h2database"><a href="#h2database" class="headerlink" title="h2database"></a>h2database</h2><h3 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h3><p>这个数据库是开源的非常快，并且可以使用jdbc api来操作，有内嵌式和服务两种运行模式，并且是基于内存的数据库，还可以基于浏览器的客户端进行操作，jar包非常小，只需要2mb的jar包就可以运行，所以有些需要数据比较小的缓存的时候，可以考虑一下H2，毕竟搭建redis相对还是比较麻烦的，而且成本也较高。</p><h3 id="2-使用流程："><a href="#2-使用流程：" class="headerlink" title="2.使用流程："></a>2.使用流程：</h3><p>&emsp;1.导入依赖：  </p><pre><code>&lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;1.4.197&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;  </code></pre><p>&emsp;2.配置运行模式：<br>&emsp;&emsp;2.1 内嵌式(一)：主要有两种，一种是内存模式，这种模式不会落地持久化，比较适合测试，关闭连接后数据库就清空  </p><pre><code>private static final String JDBC_URL = &quot;jdbc:h2:mem:DBName;DB_CLOSE_DELAY=-1&quot;;</code></pre><p>&emsp;&emsp;2.2 内嵌式(二)：持久化模式，这种模式会将数据落地持久化到指定的目录，生成与数据库同名的.mv.db文件</p><pre><code>private static final String JDBC_URL = &quot;jdbc:h2:./test&quot;;  </code></pre><p>&emsp;&emsp;2.3 服务式：服务式就是指定一个tcp的远程目录</p><pre><code>private static final String JDBC_URL = &quot;jdbc:h2:tcp://localhost/~/test”；</code></pre><p>&emsp;3.配置连接参数：</p><pre><code>//用户名private static final String USER = &quot;sa&quot;;//连接数据库时使用的密码，默认为空private static final String PASSWORD = &quot;&quot;;//连接H2数据库时使用的驱动类，org.h2.Driver这个类是由H2数据库自己提供的，在H2数据库的jar包中可以找到private static final String DRIVER_CLASS = &quot;org.h2.Driver&quot;;  </code></pre><p>&emsp;4.创建连接：  </p><pre><code>// 加载H2数据库驱动Class.forName(DRIVER_CLASS);// 根据连接URL，用户名，密码获取数据库连接Connection conn = DriverManager.getConnection(JDBC_URL, USER, PASSWORD);</code></pre><p>&emsp;5.简单使用：<br>&emsp;现在我们就可以根据前面创建的连接，进行各种操作了，H2数据库基本类似于Mysql，所以语句也基本相同，另外H2添加自定义函数也很简单，创建一个类，类里定义一个静态的公共方法，然后执行下面的语句就可以添加一个函数了  </p><pre><code>// functionName 为H2中使用的名字，不能重名，package.className.functionName则是方法的路径，从包名到方法名都需要加上CREATE ALIAS IF NOT EXISTS  functionName FOR &quot;package.className.functionName&quot;  </code></pre><p>&emsp;6.注意：H2的视图并不是随原表更新的  </p><h3 id="3-H2的本地使用"><a href="#3-H2的本地使用" class="headerlink" title="3.H2的本地使用"></a>3.H2的本地使用</h3><p>&emsp;1.下载jar包<br>&emsp;这一步参考前面的导入依赖，将jar包下载到本地<br>&emsp;2、运行<br>&emsp;打开cmd.exe（window，linux未测试），然后使用java -jar jar包路径，就可以运行H2数据库了，他会自动打开网页的客户端，默认使用的是持久化模式，可以用来测试语句等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法篇三(查询数组中第二大的数)</title>
      <link href="/p/76991e03.html"/>
      <url>/p/76991e03.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="查询数组中第二大的数"><a href="#查询数组中第二大的数" class="headerlink" title="查询数组中第二大的数"></a>查询数组中第二大的数</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>  一开始的想法是冒泡排序，就是遍历两遍，重新排列数组，然后取第二大的数<br>  代码如下：</p><pre><code>private int func1(int[] arr) {    for (int i = 0; i &lt;arr.length-1 ; i++) {        for (int j = i+1; j &lt;arr.length; j++) {            if (arr[i] &gt;= arr[j]) {                int temp = arr[i];                arr[i] = arr[j];                arr[j] = temp;            }        }    }    return arr[arr.length-2];}但是它的时间复杂度是O(n平方)，有没有其他的方法  </code></pre><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><pre><code>只需要一次遍历，因为我们并不需要将数组进行重排，只需要取数就好了，所以我们把数记下来，代码如下：private int func(int[] arr) {    int a = 0;    int b = 0;    for(int i = 0;i&lt;arr.length-1;i++){        if(arr[i]&gt;a){            b=a;            a = arr[i];        }    }    return b;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法篇二(分治思想下的归并排序)</title>
      <link href="/p/865b78ec.html"/>
      <url>/p/865b78ec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分治思想下的归并排序"><a href="#分治思想下的归并排序" class="headerlink" title="分治思想下的归并排序"></a>分治思想下的归并排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&emsp;1.归并思想：首先把一个数组中的元素，按照某一方法，先拆分了之后，按照一定的顺序各自排列，然后再归并到一起，使得归并后依然是有一定顺序的 。<br>&emsp;2.归并排序算法可以利用递归的思想或者迭代的思想去实现。首先我们先把一个无序的数组去拆分，然后利用一定的规则，去合并。类似于二叉树的结构。其总的时间复杂度为O( n log n)。空间复杂度为 S（nlogn）</p><h3 id="题目-Leetcode-面试51"><a href="#题目-Leetcode-面试51" class="headerlink" title="题目(Leetcode-面试51)"></a>题目(Leetcode-面试51)</h3><p>&emsp;题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>&emsp;&emsp;例子：输入[7,5,6,4] 输出 5 </p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>1.暴力求解法：一开始我使用的是暴力法，就是直接遍历，用前值去比较后值，如果前值大就加1 ，这样，这个程序的时间复杂度为o(n的平方)，短的数组可能并不会有什么大的问题，但是数组长度太长的话，他的效率会非常的低。、<br>&emsp;代码如下：  </p><pre><code>    class Solution {        public int reversePairs(int[] nums) {            int count = 0;            for(int i=0;i&lt;nums.length-1;i++){                for(int j=i+1;j&lt;nums.length;j++){                    if(nums[i]&gt;nums[j]){                        count++;                    }                }            }            return count;        }    }</code></pre><p>2.归并排序：<br>&emsp;所有的逆序对来自于3个地方<br>&emsp;&emsp;1.左边区间的逆序对，<br>&emsp;&emsp;2.右边区间的逆序对，<br>&emsp;&emsp;3.横跨两个区间的逆序对<br>&emsp;所以我们选择在第二个子区间归并回去的时候，计算逆序对的个数：<br>&emsp;&emsp;代码如下：</p><pre><code>class Solution {    public int reversePairs(int[] nums) {        int len = nums.length;        int[] copy new int[len];        if(len &lt;2){            return 0;        }        for(int i=0;i&lt;len;i++){            copy[i] = nums[i];        }        int[] temp = new int[len];        return reversePairs(copy,0,len-1,temp)；    }    private int reversePairs(int[] copy,int start,int end,int[] temp){        if(start == end){            return 0;        }        int mid = start + (end-start)/2;        int leftPairs = reversePairs(copy,start,mid,temp);        int rightPairs = reversePairs(copy,mid+1,end,temp);        if(copy[mid]&lt;copy[mid+1]){            return leftPairs+rightPairs;        }        int crossPairs = mergeAndCount(nums, start, mid, end, temp);        return leftPairs + rightPairs + crossPairs;    }    private int mergeAndCount(int[] copy,int start,int mid,int end,int[] temp){        for(int i=start;i&lt;end+1;i++){            temp[i] = copy[i];        }        int i = start;        int j = mid+1;        for(int k=start;k&lt;end+1;k++){            // 有下标访问，得先判断是否越界            if (i == mid + 1) {                copy[k] = temp[j];                j++;            } else if (j == right + 1) {                copy[k] = temp[i];                i++;            } else if (temp[i] &lt;= temp[j]) {                // 注意：这里是 &lt;= ，写成 &lt; 就不对，因为只有&gt;时才是逆序对                copy[k] = temp[i];                i++;            } else {                copy[k] = temp[j];                j++;                // 在 j 指向的元素归并回去的时候，计算逆序对的个数，只多了这一行代码                count += (mid - i + 1);            }        }        return count;        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法篇一(分治思想下的快速排序)</title>
      <link href="/p/a7dadbec.html"/>
      <url>/p/a7dadbec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分治思想下的快速排序"><a href="#分治思想下的快速排序" class="headerlink" title="分治思想下的快速排序"></a>分治思想下的快速排序</h2><h3 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h3><p>&emsp;1.分治法的设计思想：把一个难以解决的大问题，分割成几个规模较小的相同问题，然后处理这些小问题，最终解决这个大问题。<br>&emsp;2.分治策略:对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。<br>&emsp;3.如果原问题可以分割成k个子问题（1&lt;k&lt;=n），而且这些小问题都可解，并且可以根据这些小问题的解求出原问题的解，那么就可以使用分治法，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。<br>&emsp;4.分治适用的情况：<br>&emsp;&emsp;1.该问题的规模缩小到一定的程度就可以容易地解决<br>&emsp;&emsp;2.该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质<br>&emsp;&emsp;3.利用该问题分解出的子问题的解可以合并为该问题的解<br>&emsp;&emsp;4.该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题  </p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>&emsp;1.基本思想：<br>&emsp;&emsp;1.先从数组中选取一个基准数，通常是a[0]<br>&emsp;&emsp;2.对数组进行分区，比基准数大的放到右边，比基准数小的放到左边<br>&emsp;&emsp;3.对两个分区再次进行1.2步的操作，重复下去，知道数组排序完成<br>&emsp;2.代码实现(java):    </p><pre><code>public static void main(String[] args) {    int[] arr = {32,12,53,25,64,62,41,33,7};    new demo2().quickSort(arr, 0, arr.length - 1);    System.out.println(Arrays.toString(arr));}private void quickSort(int[] arr, int start, int end) {    if(start&gt;=end){        return;    }    int k=arr[start];    int i=start,j=end;    while (i!=j){        while(i&lt;j&amp;&amp;arr[j]&gt;=k) {            --j;        }        swap(arr,i,j);        while(i&lt;j&amp;&amp;arr[i]&lt;=k) {            ++i;        }        swap(arr, i, j);    }    //分治思想    quickSort(arr,start,i-1);    quickSort(arr,i+1,end);}private void swap(int[] arr, int i, int j) {    int temp;    temp = arr[i];    arr[i]=arr[j];    arr[j]=temp;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数二(不定积分)</title>
      <link href="/p/b01bbb31.html"/>
      <url>/p/b01bbb31.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="不定积分相关整理"><a href="#不定积分相关整理" class="headerlink" title="不定积分相关整理"></a>不定积分相关整理</h2><h3 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h3><p>  1.F(x)的导数是f(x)，那么就称F(x)是f(x)的原函数<br>  需要明确：<br>  &emsp;连续函数一定有原函数<br>  &emsp;且原函数有无数个 ，及F(x)+C, C为常数<br>  2.第一类换元积分法：<br>    &emsp;∫f[g(x)].g’(x)dx = ∫[f(g(x)]d[g(x)] =(令g(x)=t)=&gt; ∫f(t)dt = F(t)+C = F[g(x)]+C<br>  3.第二类换元积分法；<br>    &emsp;∫f(x)dx =(x=g(t))=&gt; ∫f[g(t)]d[g(t)] = ∫h(t)dt = H(t)+C<br>  4.分布积分法<br>    &emsp;概念：∫udv = uv-∫vdu<br>    &emsp;1.∫幂函数<em>指数函数 dx (∫X^2.e^x dx)<br>    &emsp;2.∫幂函数</em>对数函数 dx (∫X^2.lnx dx)<br>    &emsp;3.∫幂函数<em>三角函数 dx (∫X^2.cosx dx)<br>    &emsp;4.∫幂函数</em>反三角函数 dx (∫X^2.arccosx dx)<br>    &emsp;5.∫e^ax.①cosbx ②sinbx dx (∫e^2x.cos2x dx)<br>      &emsp;&emsp;注意：第五种的备注:记得 （i=∫e^ax.①cosbx ②sinbx dx） 因为在后面一定会得到一个相同的式子，要进行计算，得出答案<br>    &emsp;6.∫①sec^n x dx<br>       &emsp;&emsp;②csc^n x dx<br>       &emsp;&emsp;注意：第六类备注：n一定是奇数次，如果是偶数次的话，用半角或其他公式进行降次<br>    5.有理函数不定积分<br>        &emsp;1.假分式：（分子次数比分母大）<br>          &emsp;注意：要把假分式化成：多项式+真分式<br>          &emsp;2.真分式：<br>          &emsp;&emsp;①分母可以因式分解进行因式分解<br>          &emsp;&emsp;&emsp;1.1/(x-1)(x-2) ==&gt; A/(x-1) + B/(x-2)<br>          &emsp;&emsp;&emsp;2.(2x-1)/(x-1)(x^2+1) =&gt; A/(x-1) + (Bx+C)/(x^2+1)<br>          &emsp;&emsp;&emsp;…<br>          &emsp;&emsp;②分母不可以因式分解<br>          &emsp;&emsp;&emsp;忘了，全凭悟性了嘛 </p><h3 id="第二类积分法的相关类型"><a href="#第二类积分法的相关类型" class="headerlink" title="第二类积分法的相关类型"></a>第二类积分法的相关类型</h3><pre><code> 1.无理转化成有理    注意；通常是开根号的   2.平方和和平方差  </code></pre><h3 id="一些需要记的工具"><a href="#一些需要记的工具" class="headerlink" title="一些需要记的工具"></a>一些需要记的工具</h3><p><img src="https://i.loli.net/2020/06/16/rVguiCR84JXhep5.jpg" alt="基本公式"><br><img src="https://i.loli.net/2020/06/16/bDMVCRwgAzXJfeP.jpg" alt="平方和平方差"><br><img src="https://i.loli.net/2020/06/16/yBigDPCUpmq9nu8.jpg" alt="习题中遇到的"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数二(第四弹)</title>
      <link href="/p/3cb64991.html"/>
      <url>/p/3cb64991.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单调性与极值方面的整理"><a href="#单调性与极值方面的整理" class="headerlink" title="单调性与极值方面的整理"></a>单调性与极值方面的整理</h2><h3 id="极值点的充分条件"><a href="#极值点的充分条件" class="headerlink" title="极值点的充分条件"></a>极值点的充分条件</h3><pre><code>1.第一充分条件：    - [f&#39;(x)&gt;0,x&lt;x0] &amp;&amp; [f&#39;(x)&lt;0,x&gt;x0]  ==&gt; x=x0是f(x)的极大点    - [f&#39;(x)&lt;0,x&lt;x0] &amp;&amp; [f&#39;(x)&gt;0,x&gt;x0]  ==&gt; x=x0是f(x)的极小点  2.第二充分条件:    当f&#39;(x0)=0时，    - f&#39;&#39;(x0)&gt;0, x=x0是f(x)的极小点      - f&#39;&#39;(x0)&lt;0, x=x0是f(x)的极大点</code></pre><h3 id="凹凸函数的定义"><a href="#凹凸函数的定义" class="headerlink" title="凹凸函数的定义"></a>凹凸函数的定义</h3><pre><code>1.凹函数        在f(x)∈c[a,b] (a,b)内可导,有 [(f(b)-f(a)]/2 &gt; f[(a+b)/2],则称f(x)在[a,b]为凹2.凸函数        在f(x)∈c[a,b] (a,b)内可导,有 [(f(b)-f(a)]/2 &lt; f[(a+b)/2],则称f(x)在[a,b]为凸  3.判别法      在f(x)∈c[a,b] (a,b)内二阶可导：          - f&#39;&#39;(x)&gt;0,在[a,b]上为凹函数        - f&#39;&#39;(x)&lt;0,在[a,b]上为凸函数          4.拐点      定义：x=x0两侧的凹凸性不相同,或者说 f&#39;&#39;(x0)=0 &amp;&amp; f&#39;&#39;&#39;(x0) != 0,则(x0,f(x0))称为f(x)的拐点  </code></pre><h3 id="渐近线"><a href="#渐近线" class="headerlink" title="渐近线"></a>渐近线</h3><pre><code>1.水平渐近线      f(x)&gt;A (x-&gt;无穷) y=A 就是f(x)的水平渐近线  2.铅直渐近线      铅直渐近线都是在f(x)的断点处,如果：        f(x)=无穷 (x-&gt;x0) 或者 f(xo+0)=无穷 或者 f(x0-0)=无穷 那么, x=x0就是f(x)的铅直渐近线  3.斜渐近线      如果 [f(x)/x]=a (x-&gt;无穷),[f(x)-ax]=b (x-&gt;无穷),则称y=ax+b 为f(x)的斜渐近线</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数二(第三弹)</title>
      <link href="/p/1d9f15f.html"/>
      <url>/p/1d9f15f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="中值定理的整理"><a href="#中值定理的整理" class="headerlink" title="中值定理的整理"></a>中值定理的整理</h2><h3 id="罗尔中值定理-Rolle"><a href="#罗尔中值定理-Rolle" class="headerlink" title="罗尔中值定理  (Rolle)"></a>罗尔中值定理  (Rolle)</h3><ul><li>三个条件：  </li></ul><p>   1.f(x)∈c[a,b]<br>   2.(a,b)上可导<br>   3.f(a)=f(b)<br>   由此可以得到:<br>        在(a,b)之间一定存在一个值ξ,使得[f(b)-f(a)]/[b-a]=f’(ξ)=0  </p><h3 id="拉格朗日中值定理-（Lagrange）"><a href="#拉格朗日中值定理-（Lagrange）" class="headerlink" title="拉格朗日中值定理 （Lagrange）"></a>拉格朗日中值定理 （Lagrange）</h3><ul><li>两个条件：其实就是罗尔中值定理，就是L的一个特殊情况：</li></ul><p>   1.f(x)∈c[a,b]<br>   2.(a,b)上可导<br>   由此可以得到：<br>        在(a,b)之间一定存在一个值ξ,使得[f(b)-f(a)]=f’(ξ)[b-a]</p><h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><pre><code>- 三个条件：1.f(x),g(x)∈c[a,b]  2.(a,b)上可导  3.g&#39;(x)!=0  由此可以得出：    在(a,b)之间一定存在一个值ξ,使得[f(b)-f(a)]/[g(b)-g(a)] = f&#39;(ξ)/g&#39;(ξ)  </code></pre><h3 id="基本的题型"><a href="#基本的题型" class="headerlink" title="基本的题型"></a>基本的题型</h3><pre><code>- f(x)的n级导数=0  - 只有ξ一个字母，没有其他字母：    1.还原法,还原法有三个条件：        1.仅有ξ          2.两项(一般一个复杂，一个简单)        3.导数差一阶,例如f&#39;&#39;(ξ) 和 f&#39;(ξ)        方法就是凑：        工具是：f&#39;(x)/f(x) = {ln[f(x)]}&#39;    2.分组法：        1.三项，各差一阶  (把f&#39;(x)当中间项来凑)        2.差二阶        例子：证明：在(a,b)之间一定存在一个值ξ,使得f&#39;&#39;(ξ) = f&#39;(ξ)- 结论中含ξ，含a,b      1.ab和ξ可以分离      方法：1.ab和ξ分离            2.从a,b入手：f(b)-f(a)/b-a 用拉格朗日；f(b)-f(a)/g(b)-g(a) 用柯西      2.ab和ξ不可以分离 ：凑微法  - 结论中含有两个或者两个以上中值      1.结论中只含f&#39;(ξ)和f&#39;(η)          方法：找出第三个点,用两次拉格朗日中值定理      2.结论中只含两个中值ξ,η ,但是关于两个中值的项复杂度不同          方法：把ξ,η分开，方法必留复杂        ()&#39; 用两次拉格朗日中值定理 ()&#39;/()&#39; 用柯西      3.结论中只含ξ,η，不仅仅只包含f&#39;(ξ)和f&#39;(η)两者对应的项完全对等          方法：先就ξ构造一个辅助函数（还原法），在两次使用拉格朗日中值定理</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数二(第二弹)</title>
      <link href="/p/84f1df24.html"/>
      <url>/p/84f1df24.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章知识点总结"><a href="#第一章知识点总结" class="headerlink" title="第一章知识点总结"></a>第一章知识点总结</h2><h3 id="断点相关"><a href="#断点相关" class="headerlink" title="断点相关"></a>断点相关</h3><ul><li><p>需要分左右的情形：<br>  1.arctan 1/(x-a)  (x-&gt;0)<br>  2.1/x-a (x-&gt;a)<br>  3.x-a的绝对值<br>  这些需要分左右进行讨论  </p></li><li><p>题目中如果有f(x)/x (x-&gt;0) = 一个常数<br>  那么 f(0) = 0;  </p></li><li><p>2^x-1 不等价于x<br> 首先需要把底换成e，原式等于e^xln2-1 等价于xln2  </p></li><li><p>麦克劳林公式整理<br>  1.使用麦克劳林公式时，x要趋于零<br>  2.常用分为以下几种：  </p><pre><code>  1.sinx = x-x^3/3!+x^5/5!-x^7/7!+...+(-1)^n x^2n+1/(2n+1)! + 0(x^2n+1)    2.e^x = 1+x+x^2/2!+x^3/3!+...+x^n/n! + 0(x^n)    3.cosx = 1-x^2/2!+x^4/4!-x^6/6!+...+(-1)^n x^2n/2n! + 0(x^2n)    4.ln(1+x) = x-x^2/2!+x^3/3!+...+(-1)^(n-1) x^n/(n)! + 0(x^n)    5.(1+x)^a = 1+ax+a(a-1).x^2/2!+...+a(a-1)(a-2)...(a-n+1)x^n/n! + 0(x^n)  </code></pre></li><li><p>ln^nx = nlnx  </p></li><li><p>1-cos^ax =ax^2/x  </p></li><li><p>证明极限存在，证明有界和单调  </p></li><li><p>cos2x = 1- 2sin^2x  </p></li><li><p>f(x)为奇函数，那么f’(x)为偶函数  </p></li><li><p>遇到  (ax+b)/(x-1)(x-2) 这种题目求f^(n)(x)<br>  要把原式化成A/(x-1)+B/(x-2) 求出AB，再求导数  </p></li></ul><h2 id="总结常用初等函数的求导"><a href="#总结常用初等函数的求导" class="headerlink" title="总结常用初等函数的求导"></a>总结常用初等函数的求导</h2><ul><li>(tanx)’ = 1/cosx^2 = sec^2x </li><li>(arctanx)’ = 1/(1+x^2)  </li><li>(arcsinx)’ = 1/(1+x^2)^(1/2)</li><li>(arccosx)’ = -1/(1+x^2)^(1/2)</li><li>tanx^2 = sec^2x-1</li></ul><h2 id="立方和"><a href="#立方和" class="headerlink" title="立方和"></a>立方和</h2><ul><li>x^3+y^3 = (x+y)(x^2-xy+y^2)  </li></ul><h2 id="立方差"><a href="#立方差" class="headerlink" title="立方差"></a>立方差</h2><ul><li>x^3-y^3 = (x-y)(x^2+xy+y^2)</li></ul><h2 id="f-x-可导"><a href="#f-x-可导" class="headerlink" title="f(x)可导"></a>f(x)可导</h2><pre><code>代表f(x)可微，Δy = dy + 0(Δx);  即 Δy-dy是Δx 的高阶无穷小</code></pre><h2 id="拆的原则"><a href="#拆的原则" class="headerlink" title="拆的原则"></a>拆的原则</h2><pre><code>分子的精确度不低于分母的精确度</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数二(第一弹)</title>
      <link href="/p/cc9932e.html"/>
      <url>/p/cc9932e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章：函数，极限，连续"><a href="#第一章：函数，极限，连续" class="headerlink" title="第一章：函数，极限，连续"></a>第一章：函数，极限，连续</h2><h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><p>  1.函数的几种特性：  </p><ul><li>函数的有界性：在定义域D中如果任意x都使得f(x)&lt;=K,则函数有上界，K是函数的一个上界，如果任意x使得f(x) &lt;= N，则函数有下届，N是函数的一个下届</li><li>函数的单调性：在定义域的一个区间中，单调递增或单调递减</li><li>函数的奇偶性：f(-x) = f(x)为偶函数，f(-x) = -f(x) 为奇函数</li><li>函数的周期性：在函数定义域D中，如果存在 l 使得 f(x+l) = f(x) 则函数是周期函数，l是函数f(x)的周期</li><li>反函数：D-&gt;f(D)是单射，则存在逆映射f^-1：f(D) -&gt; D,则称该逆映射是f的反函数</li><li>复合函数：多个函数复合例如y=f[g(x)]  </li></ul><p>2.基本初等函数的分类：<br>  基本初等函数包括：<br>  概念：由常数和基本初等函数经过有限次四则运算和有限次的函数复合步骤所构成并可用一个式子表示的函数，称为初等函数。 </p><ul><li>幂函数：y=xμ.y=xμ. (μ∈Rμ∈R是常数) </li><li>指数函数：y=ax(a&gt;0y=ax(a&gt;0且a≠1)a≠1)  </li><li>对数函数：y=logaxy=loga⁡x（a&gt;0a&gt;0且a≠1a≠1，特别当a=ea=e时，记为y=lnxy=ln⁡x） </li><li>三角函数：如y=sinxy=sin⁡x，y=cosxy=cos⁡x，y=tanxy=tan⁡x等。 </li><li>反三角函数：如y=arcsinxy=arcsin⁡x，y=arccosxy=arccos⁡x，y=arctanxy=arctan⁡x等</li></ul><h3 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h3><p>1.数列的定义：按照某一个法则，对于每一个n包含与N+，对应着一个确定的实数xn,这些实数按照下标从小到大排列构成一个序列</p><ul><li>定义： 设{xn}为一个数列，如果存在常数a，对于任意给定的ε（不论它多么小），总存在正整数N，是得当n&gt;N时，不等式 |xn-a| &lt; ε成立，则称常数a时数列{xn}的极限，或该数列收敛于a。<br>该定义的目的是判断一个数列是极限是否是a  </li></ul><p>2.主要应用：我们根据上面的定义，任意给定一个数ε（这个数是个变量，代表无穷小），然后根据定义求出N（如果存在的话），使得当n&gt;N时上面的不等式 |xn-a| &lt; ε成立，我们的主要目标是求得这个N，<br>3.收敛数列的性质：</p><ul><li>定理1（极限的唯一性）：如果数列{xn}收敛，那么它的极限唯一</li><li>定理2（收敛数列的有界性）：如果数列{xn}收敛，那么这个数列一定有界</li><li>定理3（收敛数列的保号性）：如果数列收敛于a，且a&gt;0(或a&lt;0)，那么存在正整数N，当n&gt;N时，都有xn&gt;0（或xn&lt;0）</li><li>定理4（收敛数列与其子数列间的关系）：如果数列{xn}收敛于a，那么它的任一子数列也收敛，且极限也是a。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第六弹)</title>
      <link href="/p/d34b5776.html"/>
      <url>/p/d34b5776.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记5-26日工作遇到的问题"><a href="#记5-26日工作遇到的问题" class="headerlink" title="记5.26日工作遇到的问题"></a>记5.26日工作遇到的问题</h2><h3 id="idea-maven工程生成wsdl文件"><a href="#idea-maven工程生成wsdl文件" class="headerlink" title="idea maven工程生成wsdl文件"></a>idea maven工程生成wsdl文件</h3><ul><li>问题：由于我的server文件放在了test里面，所以第一次生成的时候报了ClassNotFoundException的异常  </li><li>解决方法：构建路径的时候并不是走test，所以找不到对应的路径，在java文件夹里给上固定的路径就可以拿到wsdl文件了  </li></ul><h3 id="使用CXF时因缺少对应jar包而报错问题汇总"><a href="#使用CXF时因缺少对应jar包而报错问题汇总" class="headerlink" title="使用CXF时因缺少对应jar包而报错问题汇总"></a>使用CXF时因缺少对应jar包而报错问题汇总</h3><p>  1.org.apache.catalina.LifecycleException: A child Container failed during start<br>    缺少：cxf-core-x.x.x.jar（最核心的包）<br>  2.Java.lang.ClassNotFoundException: org.apache.cxf.binding.soap.SoapBindingConfiguration<br>    缺少：cxf-rt-bindings-soap-x.x.x.jar       （soap协议）<br>  3.org.apache.cxf.jaxb.JAXBDataBinding：<br>    缺少：cxf-rt-databinding-jaxb-x.x.x.jar<br>  4.加载Application文件时出现Unable to locate Spring NamespaceHandler for XML schema namespace (<a href="http://cxf.apache.org/jaxws" target="_blank" rel="noopener">http://cxf.apache.org/jaxws</a>)<br>    缺少：cxf-rt-frontend-jaxws-x.x.x.jar<br>  5.org/apache/cxf/frontend/spring/ClientProxyFactoryBeanDefinitionParser错误：<br>    缺少：cxf-rt-frontend-simple-x.x.x.jar<br>  6.class path resource [META-INF/cxf/cxf-servlet.xml] cannot be opened because it does not exist<br>    缺少：cxf-rt-transports-http-x.x.x.jar<br>  7.org.apache.cxf.BusException: No DestinationFactory was found for the namespace <a href="http://cxf.apache.org/transports/udp" target="_blank" rel="noopener">http://cxf.apache.org/transports/udp</a>.<br>    缺少：cxf-rt-transports-udp-x.x.x.jar<br>  8.org.apache.cxf.ws.discovery.internal.WSDiscoveryServiceImpl startup 警告: Could not start WS-Discovery Service.javax.xml.ws.WebServiceException: java.lang.NullPointerException 不能初始化配置的bean服务，也就是运行到时出错<br>    缺少：cxf-rt-ws-addr-x.x.x.jar<br>  9.java.lang.ClassNotFoundException: org.apache.cxf.ws.policy.AssertionInfoMap<br>    缺少：cxf-rt-ws-policy-x.x.x.jar<br>  10.java.lang.ClassNotFoundException: org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean<br>    缺少：cxf-rt-wsdl-x.x.x.jar<br>  11.java.lang.ClassNotFoundException: org.apache.neethi.AssertionBuilderFactory<br>    缺少：neethi-x.x.x.jar<br>  12.java.lang.ClassNotFoundException: org.slf4j.LoggerFactory<br>    缺少：slf4j-api-x.x.x.jar<br>  13.java.lang.ClassNotFoundException: org.apache.ws.commons.schema.resolver.URIResolver<br>    缺少：xmlschema-core-x.x.x.jar </p><h3 id="何鸿燊"><a href="#何鸿燊" class="headerlink" title="何鸿燊"></a>何鸿燊</h3><ul><li>这个字读shen </li></ul><h3 id="何猷君"><a href="#何猷君" class="headerlink" title="何猷君"></a>何猷君</h3><ul><li>这个字读you</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第五弹))</title>
      <link href="/p/e2102844.html"/>
      <url>/p/e2102844.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记5-25好工作中遇到的问题"><a href="#记5-25好工作中遇到的问题" class="headerlink" title="记5.25好工作中遇到的问题"></a>记5.25好工作中遇到的问题</h2><p> 今天主要是前端相关，用springboot里面的thymeleaf以及bootstrap遇到的一些问题  </p><h3 id="如何在表格中显示checkbox"><a href="#如何在表格中显示checkbox" class="headerlink" title="如何在表格中显示checkbox"></a>如何在表格中显示checkbox</h3><ul><li><p>问题：从bootStrap上弄下来的组件不显示checkbox，导致无法选取某一行  </p></li><li><p>解决方法：<br>在列名处加上了一列：  </p><pre><code> &lt;th&gt;     &lt;input id=&quot;selall&quot; type=&quot;checkbox&quot; onclick=&quot;checkOrCancelAll();&quot;&gt; &lt;/th&gt;   相当于占了一列的位置  </code></pre><p>在遍历数据的地方加上：  </p><pre><code> &lt;td&gt;     &lt;input type=&quot;checkbox&quot; th:value=&quot;${task.id}&quot; name=&quot;allTask&quot; &gt; &lt;/td&gt;   这样就可以显示出checkbox那一列了  </code></pre><h3 id="checkbox的全选以及全部取消"><a href="#checkbox的全选以及全部取消" class="headerlink" title="checkbox的全选以及全部取消"></a>checkbox的全选以及全部取消</h3></li><li><p>问题：checkbox显示出来了，但是彼此之间没有联系，比如，在点击列名的checkbox时，应该所有的checkbox都被选中，再点，全部取消  </p></li><li><p>解决方法：  添加了一个function，思路是先判断点列名的checkbox时，是true还是false，如果是true，全选，如果是false，全部取消，代码如下:    </p><p>  function checkOrCancelAll() {</p><pre><code> var selall = document.getElementById(&quot;selall&quot;); //2.获取选中状态 var checkedSelall = selall.checked; //console.log(checkedSelall) //3.若checked=true,将所有的复选框选中,checked=false,将所有的复选框取消 var allCheck = document.getElementsByName(&quot;allTask&quot;); //4.循环遍历取出每一个复选框中的元素 if (checkedSelall) {     list=[];     //全选     for (var i = 0; i &lt; allCheck.length; i++) {         //设置复选框的选中状态         allCheck[i].click();         //console.log(list);         allCheck[i].checked = true;     }     //mySpan.innerHTML=&quot;取消全选&quot;; } else {     //取消全选     for (var i = 0; i &lt; allCheck.length; i++) {         allCheck[i].checked = false;         list=[];         //console.log(list);     } }</code></pre><p> }  </p><h3 id="点击普通的checkbox时，获取相应的id"><a href="#点击普通的checkbox时，获取相应的id" class="headerlink" title="点击普通的checkbox时，获取相应的id"></a>点击普通的checkbox时，获取相应的id</h3></li><li><p>问题： 我们选中checkbox，是为了方法服务，我们需要把选中行的数据的id放到集合里，传到后端进行操作，一开始，并不能直接得到id  </p></li><li><p>解决方法： 我们创建一个全局的list集合，之后通过thymeleaf中的方法(name=”allTask” th:onclick=”‘javascript:checkOrCancelOne(‘+${task.id}+’);’”)，拿到每一个对应的id，然后把他们传到全局变量的集合中，这样，就完成了对id的集中<br>代码如下：  </p></li></ul><pre><code>function checkOrCancelOne(id) {    //第一次进来，id一定是不存在的，就push进去，第二次一定是取消操作，    //这个时候调用list的splice方法，将对应的id删除    var num = list.indexOf(id);    if(num &gt; -1){        console.log(num);        list.splice(num,1);    }else{        list.push(id);    }    console.log(list);}  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第四弹)</title>
      <link href="/p/4fef6a30.html"/>
      <url>/p/4fef6a30.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记5-22号工作中遇到的问题"><a href="#记5-22号工作中遇到的问题" class="headerlink" title="记5.22号工作中遇到的问题"></a>记5.22号工作中遇到的问题</h2><h3 id="集合迭代器使用报错"><a href="#集合迭代器使用报错" class="headerlink" title="集合迭代器使用报错"></a>集合迭代器使用报错</h3><ul><li>报错：Exception in thread “main” java.util.ConcurrentModificationException  </li><li>问题：代码如下：<br>while(iterator.hasNext()){<pre><code>      Integer key = iterator.next();      if(key.equals(k)){          map.remove(key);      }  }</code></pre>  }<br>  使用了迭代器遍历，但是在删除时，调用了map的删除方法，我忘记了一点：map在进行遍历操作的时候，是不能做修改操作的，如果做了，就会报错  </li><li>解决方法：调用迭代器的删除方法，代码如下：<br>  while(iterator.hasNext()){<pre><code>      Integer key = iterator.next();      if(key.equals(k)){          iterator.remove(); //注意这里的不同      }  }</code></pre>  }  </li></ul><h3 id="注解报错"><a href="#注解报错" class="headerlink" title="注解报错"></a>注解报错</h3><ul><li>报错：Unable to close ApplicationContext；org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration’  </li><li>问题：Mapper层没有添加@Mapper注解，以为一个简单的@Repository就可以了  </li><li>原因：@Mapper是Mybatis的注解，是用来说明这个是一个Mapper，对应的xxxMapper.xml就是来实现这个Mapper,如果是改成了@repository，使用的是Spring的Bean注解，当然是不可以的</li><li>解决方法：在类前面添加@Mapper注解  </li></ul><h3 id="导入SSL证书到JDK里"><a href="#导入SSL证书到JDK里" class="headerlink" title="导入SSL证书到JDK里"></a>导入SSL证书到JDK里</h3><ul><li>以阿里云镜像库举例子：  </li></ul><p>1.首先去下载证书到本地<br>2.cmd 输入：keytool -import -alias xxx -keystore <JAVA_HOME>/jre/lib/security/cacerts -file xxx.cer<br>3.如果有确认提示，y就好了，很多人做完上面第一步就好了<br>4.如果还未好：将下面的内容加入sts.ini 或者是 eclipse.ini 中<br>-Djavax.net.ssl.trustStore=<JAVA_HOME>\jre\lib\security\cacerts -Djava.net.ssl.trustStorePassword=changeit</p>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册域名之后踩的坑</title>
      <link href="/p/e9ddbaa9.html"/>
      <url>/p/e9ddbaa9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="注册域名之后踩的坑"><a href="#注册域名之后踩的坑" class="headerlink" title="注册域名之后踩的坑"></a>注册域名之后踩的坑</h2><p>由于静态网页托管在github上，服务器在国外，访问速度实在是感人，所以为了速度，<br>将代码托管到了国内的coding上，于是新的问题又来了，coding托管后，gages服务开启后，<br>发现网址的前一段时随机的，简直low爆了，所以去注册了一个域名</p><h3 id="coding绑定域名，获取证书获取不到"><a href="#coding绑定域名，获取证书获取不到" class="headerlink" title="coding绑定域名，获取证书获取不到"></a>coding绑定域名，获取证书获取不到</h3><ul><li>报错：Let’s Encrypt SSL证书配置错误”DNS problem: NXDOMAIN looking up A for xxx.com”  </li><li>原因：注册完域名之后，没有解析域名  </li><li>解决方法：以我注册的华为云举例：  </li></ul><p>1.到所买的域名的界面，如下操作：<br><img src="https://i.loli.net/2020/05/21/PRjAl3dsBVvbDNJ.png" alt="图1"><br>2.注册A，CAA（需要首先去申请SSL证书，免费的）<br><img src="https://i.loli.net/2020/05/21/yafqiUhPMm7SIzp.png" alt="图2"><br>3.域名需要去实名的，个人网站好像普通的域名不用备案，企业级的需要备案：<br><img src="https://i.loli.net/2020/05/21/LgezErtRusVDpvx.png" alt="图3"><br>完事  </p><h3 id="上传图片网址"><a href="#上传图片网址" class="headerlink" title="上传图片网址"></a>上传图片网址</h3><p>markdown需要图片的话，上传图片到网上会比较好，我用的是一个小众的网址：<br><a href="https://sm.ms/" target="_blank" rel="noopener">网址</a><br>挺好用的</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第三弹)</title>
      <link href="/p/7280d2fe.html"/>
      <url>/p/7280d2fe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记5-20-5-21工作中遇到的问题"><a href="#记5-20-5-21工作中遇到的问题" class="headerlink" title="记5.20-5.21工作中遇到的问题"></a>记5.20-5.21工作中遇到的问题</h2><h3 id="首先是mybatis部分的问题"><a href="#首先是mybatis部分的问题" class="headerlink" title="首先是mybatis部分的问题"></a>首先是mybatis部分的问题</h3><h4 id="update操作的时候，代码中显示已update完成，但是数据库中对应的数据并没有更新"><a href="#update操作的时候，代码中显示已update完成，但是数据库中对应的数据并没有更新" class="headerlink" title="update操作的时候，代码中显示已update完成，但是数据库中对应的数据并没有更新"></a>update操作的时候，代码中显示已update完成，但是数据库中对应的数据并没有更新</h4><ul><li>原因：在获取sqlSession对象的时候：<br>SqlSession sqlSession = sqlSessionFactory.openSession()；</li><li>解决方法：后面的参数可以填true/false:true为自动提交事务 ,false则相反(用于是否开启事务,默认为false)<br>当我加上true后，数据库的数据就可以正常提交了：SqlSession sqlSession = sqlSessionFactory.openSession(true)；  </li></ul><h4 id="数据库添加数据，代码中无法找到新增的数据"><a href="#数据库添加数据，代码中无法找到新增的数据" class="headerlink" title="数据库添加数据，代码中无法找到新增的数据"></a>数据库添加数据，代码中无法找到新增的数据</h4><ul><li>原因：在每一次循环之后，没有关闭sqlSession，导致再次循环时，拿到的依旧是没有更新数据的sqlSession对象，<br>所以并不会找到新增的数据  </li><li>解决方法：在循环的最后将sqlSession对象close掉，保证每一次拿sqlSession对象拿到的都是最新的。</li></ul><h3 id="搭建mybatis环境的时候，-amp-符号xml文件报错"><a href="#搭建mybatis环境的时候，-amp-符号xml文件报错" class="headerlink" title="搭建mybatis环境的时候，&amp; 符号xml文件报错"></a>搭建mybatis环境的时候，&amp; 符号xml文件报错</h3><ul><li>报错信息：org.xml.sax.SAXParseException;在实体引用中, 实体名称必须紧跟在 ‘’&amp;’’ 后面  </li><li>原因：在xml文件中，&amp;读不出来  </li><li>解决方法：用&amp;代替<br>useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中遇到的问题(第二弹)</title>
      <link href="/p/f7a8fc85.html"/>
      <url>/p/f7a8fc85.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记2020-5-19遇到的问题"><a href="#记2020-5-19遇到的问题" class="headerlink" title="记2020.5.19遇到的问题"></a>记2020.5.19遇到的问题</h2><h3 id="webService-使用时，找不到分派方法"><a href="#webService-使用时，找不到分派方法" class="headerlink" title="webService 使用时，找不到分派方法"></a>webService 使用时，找不到分派方法</h3><ul><li><p>报错：org.springframework.remoting.jaxws.JaxWsSoapFaultException: Client received SOAP Fault from server: 找不到{XXXXX}function的分派方法  </p></li><li><p>原因：是在接口上，我使用的是idea自带的插件去下载wsdl上的接口，导致下载下来的接口上缺少了一些注解，如下：<br><img src="https://i.loli.net/2020/05/20/nOgEc2QFtj9PJ3T.png" alt="图1"></p></li><li><p>解决方法：webservice服务注入的bean实现的接口必须提供targetNamespace，对应的服务实现类的operationName必须和接口的operationName保持一致 不然找不到方法，修改如下：<br><img src="https://i.loli.net/2020/05/20/8S6T1a3AQ9J2bKu.png" alt="图2"></p></li></ul><h3 id="webService调用常见错误原因"><a href="#webService调用常见错误原因" class="headerlink" title="webService调用常见错误原因"></a>webService调用常见错误原因</h3><ul><li><p>如果出现这个错误:java.lang.NoClassDefFoundError: javax/xml/soap/SOAPException，原因是没有导入 axis2-saaj.jar包   </p></li><li><p>如果出现这个错误:java.lang.NoClassDefFoundError: org/apache/commons/discovery/tools/DiscoverSingleton，原因是没有导入commons-discovery.jar包   </p></li><li><p>如果出现这个错误:org.apache.commons.logging.LogFactory，原因是没有导入commons-logging.jar包   </p></li><li><p>如果出现这个错误：Exception in thread “main” javax.xml.ws.soap.SOAPFaultException: Error invoking (……) Nested exception is java.lang.reflect.InvocationTargetException: null，原因是代码上传到服务器时不完全导致的。  </p></li><li><p>如果客户端使用的是axis调用webservice方式，服务器端收到了请求，但请求的参数显示却为null，原因是在客户端使用call.addParameter设置参数时，和发布的wsdl服务中的参数名不完全一致(大小写也要保持相同)。将客户端每个接口的参数设置为和wsdl中的相同即可。  </p></li><li><p>如果出现这个错误:java.lang.NoClassDefFoundError: javax/xml/rpc/Service，原因是没有导入jaxrpc.jar包(可以到axis官网下载对应版本的axis，在其中的lib目录可以找到)；如果使用的是maven，可以导入org.apache.axis下的axis-jaxrpc-1.4.jar。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些自己用的软件整理</title>
      <link href="/p/45bed6e9.html"/>
      <url>/p/45bed6e9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用软件以及下载地址-第一弹"><a href="#常用软件以及下载地址-第一弹" class="headerlink" title="常用软件以及下载地址(第一弹)"></a>常用软件以及下载地址(第一弹)</h2><h3 id="SoapUI-5-5-0"><a href="#SoapUI-5-5-0" class="headerlink" title="SoapUI 5.5.0"></a>SoapUI 5.5.0</h3><p>本来是想整pro版的，但是由于装的时候有报错(淦)，200多个g你跟老子讲硬盘容量不够，果断放弃 ，整了个个人版的，<br>日常测试还是够了，提取码：k15f<br><a href="https://pan.baidu.com/s/1cQaXWr9wqPX7ClbgOja1Jw" target="_blank" rel="noopener">SoapUI 提取地址</a>   </p><h3 id="STS-3-9-3-RELEASE"><a href="#STS-3-9-3-RELEASE" class="headerlink" title="STS-3.9.3-RELEASE"></a>STS-3.9.3-RELEASE</h3><p>spring官方推荐唯一正版IDE，但是自我感觉不咋滴，还是idea香，提取码：mfn8<br><a href="https://pan.baidu.com/s/1pWqrBWok9RtojU_o07yjWw" target="_blank" rel="noopener">STS 提取地址</a>   </p><h3 id="idea-2019-1-2"><a href="#idea-2019-1-2" class="headerlink" title="idea-2019.1.2"></a>idea-2019.1.2</h3><p>本来想找2019.3.4的，但是1.2用的还行，所以干脆就它吧，非常好用，idea牛批，提取码：0eyq<br><a href="https://pan.baidu.com/s/11Sa7lMiquOETGH9Leh0wCw" target="_blank" rel="noopener">idea 提取地址</a>  </p><h3 id="maven-3-5-4"><a href="#maven-3-5-4" class="headerlink" title="maven-3.5.4"></a>maven-3.5.4</h3><p>之前用过3.3.6 和 3.6.3 但是都遇到了一些兼容的问题，3.5.4的maven和idea配合，很舒服，提取码：5h9u<br><a href="https://pan.baidu.com/s/1lFaZSLBGxlOME1WgXKez7w" target="_blank" rel="noopener">maven 提取地址</a> </p><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p>注入灵魂，提取码：zbun<br><a href="https://pan.baidu.com/s/1WpUXqN2hSLOUE0C3Lr4ayw" target="_blank" rel="noopener">JDK 提取地址</a> </p><h3 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h3><p>在传一版虚拟机吧，VMWare10+centOS5.6,个人使用还可以，提取码：0dc2<br><a href="https://pan.baidu.com/s/15Y03u8pEmfC7Tgm-xw_6zw" target="_blank" rel="noopener">linux 提取地址</a> </p><h3 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h3><p>公司必备，提取码：lok3<br><a href="https://pan.baidu.com/s/1wOFSlemBJAQbnlSmK45tdA" target="_blank" rel="noopener">xshell 提取地址</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期工作中的bug(第一弹)</title>
      <link href="/p/3391d39b.html"/>
      <url>/p/3391d39b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="近期工作bug-第一弹"><a href="#近期工作bug-第一弹" class="headerlink" title="近期工作bug(第一弹)"></a>近期工作bug(第一弹)</h2><h3 id="将本地jar包导入到本地maven依赖"><a href="#将本地jar包导入到本地maven依赖" class="headerlink" title="将本地jar包导入到本地maven依赖"></a>将本地jar包导入到本地maven依赖</h3><pre><code>mvn install:install-file -Dfile=包所在位置.jar -DgroupId=${groupId} -DartifactId=${artifactId} -Dversion=${version} -Dpackaging=jar</code></pre><h3 id="本地jar包加载到依赖时"><a href="#本地jar包加载到依赖时" class="headerlink" title="本地jar包加载到依赖时"></a>本地jar包加载到依赖时</h3><pre><code>报错:Downloading from alimaven: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom[WARNING] Failed to retrieve plugin descriptor for org.apache.maven.plugins:maven-clean-plugin:2.5: Plugin org.apache.maven.plugins:maven-clean-plugin:2.5 or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-clean-plugin:jar:2.5原因:maven库中的远程库下载不了需要的插件，这时候 添加 mirror如下，完成修改  &lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;</code></pre><h3 id="JAXBException-occurred"><a href="#JAXBException-occurred" class="headerlink" title="JAXBException occurred"></a>JAXBException occurred</h3><pre><code>报错： 意外的元素 (uri:&quot;&quot;, local:&quot;msgCats&quot;)。所需元素为&lt;{}Task&gt;  - 问题：webService在soapUI调试的时候，post方式在界面上写入一个json，然而server服务端并不能知道传过来的是什么，因为缺少一个id</code></pre><p>修改前传入的是:  </p><pre><code>{    &quot;msgCats&quot;: &quot;****&quot;,    &quot;origin&quot;: &quot;****&quot;,    &quot;dest&quot;: &quot;****&quot;,    &quot;originParam&quot;: &quot;****&quot;,    &quot;estParam&quot;: &quot;****&quot;,    &quot;taskId&quot;: &quot;****&quot;}</code></pre><p>修改后:  </p><pre><code>{&quot;Task&quot;:    {    &quot;msgCats&quot;: &quot;****&quot;,    &quot;origin&quot;: &quot;****&quot;,    &quot;dest&quot;: &quot;****&quot;,    &quot;originParam&quot;: &quot;****&quot;,    &quot;estParam&quot;: &quot;****&quot;,    &quot;taskId&quot;: &quot;****&quot;    }}</code></pre><p>之后还需要在那个对象上面加上：<br>    #### @XmlRootElement(name = “Task”)<br>    以保证能找到将json转化为那个对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭起来的第一天，谈谈遇到的坑</title>
      <link href="/p/50a38d4.html"/>
      <url>/p/50a38d4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="博客搭起来的第一天，谈谈遇到的坑"><a href="#博客搭起来的第一天，谈谈遇到的坑" class="headerlink" title="博客搭起来的第一天，谈谈遇到的坑"></a>博客搭起来的第一天，谈谈遇到的坑</h2><h3 id="搭建原生hexo时报错"><a href="#搭建原生hexo时报错" class="headerlink" title="搭建原生hexo时报错"></a>搭建原生hexo时报错</h3><p>Error: your blog file is still not created, please check it yourself  </p><ul><li>原因：我的原因呢是因为在配置nodejs时，需要新建两个新的文件夹，在设置环境变量的时候设置错了  </li></ul><h3 id="修改代码之后却不能传到github-gitee-coding上"><a href="#修改代码之后却不能传到github-gitee-coding上" class="headerlink" title="修改代码之后却不能传到github/gitee/coding上"></a>修改代码之后却不能传到github/gitee/coding上</h3><ul><li>首先需要确认在根博客目录的yml文件上地址绑定正确，这里给个例子： <pre class=" language-bash"><code class="language-bash">deploy:    type: <span class="token function">git</span>    repo:         github: git@github.com:username/username.github.io.git      gitee: git@gitee.com:username/username.github.io.git  branch: master</code></pre></li><li>之后进行hexo三部曲  <pre class=" language-bash"><code class="language-bash">$ hexo clean  <span class="token comment" spellcheck="true"># 除缓存文件 (db.json) 和已生成的静态文件 (public)</span>$ hexo g <span class="token comment" spellcheck="true"># 生成静态文件</span>$ hexo d <span class="token comment" spellcheck="true"># 上传到云库上</span></code></pre>还有一个hexo s 是在本地预览，默认端口是4000，其他端口是：-p port</li></ul><h3 id="上传到gitee，不刷新界面"><a href="#上传到gitee，不刷新界面" class="headerlink" title="上传到gitee，不刷新界面"></a>上传到gitee，不刷新界面</h3><ul><li>因为gitee需要你手动去刷新page，需要你自己去服务里点 gitee pages，手动刷新界面，愿意花钱当我没说</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
